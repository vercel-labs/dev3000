/**
 * Cloud Fix Workflow - Simplified "Local-style" Architecture
 *
 * Designed to match the fast, iterative local d3k experience:
 * - 2 steps instead of many
 * - Agent controls the fix loop (not workflow orchestration)
 * - Agent has `diagnose` tool for real-time CLS feedback
 * - Report generated inline at end of agent step
 *
 * Step 1 (Init): Create sandbox, start d3k, capture initial CLS
 * Step 2 (Fix):  Agent iterates with diagnose→fix→verify until done
 */

const workflowLog = console.log

interface InitResult {
  sandboxId: string
  devUrl: string
  reportId: string
  beforeCls: number | null
  beforeGrade: "good" | "needs-improvement" | "poor" | null
  beforeScreenshots: Array<{ timestamp: number; blobUrl: string; label?: string }>
  initD3kLogs: string
  // Timing and snapshot info
  timing: {
    totalMs: number
    sandboxCreation: {
      totalMs: number
      steps: Array<{ name: string; durationMs: number; startedAt: string }>
    }
    steps: Array<{ name: string; durationMs: number; startedAt: string }>
  }
  fromSnapshot: boolean
  snapshotId?: string
}

interface FixResult {
  reportBlobUrl: string
  reportId: string
  beforeCls: number | null
  afterCls: number | null
  status: "improved" | "unchanged" | "degraded" | "no-changes"
  agentSummary: string
  gitDiff: string | null
}

interface UrlAuditResult {
  reportBlobUrl: string
  reportId: string
  beforeCls: number | null
  afterCls: number | null
  status: "improved" | "unchanged" | "degraded" | "no-changes"
  agentSummary: string
  gitDiff: string | null
}

/**
 * Main workflow - simplified to 2 steps
 */
export async function cloudFixWorkflow(params: {
  repoUrl?: string
  repoBranch?: string
  projectDir?: string
  projectName: string
  vercelOidcToken?: string
  runId?: string // Tracking ID generated by start-fix route
  userId?: string // For progress updates
  timestamp?: string // For progress updates
  workflowType?: string // For progress updates
  analysisTargetType?: "vercel-project" | "url"
  publicUrl?: string
  startPath?: string // Page path to analyze (e.g., "/about")
  customPrompt?: string // User's custom instructions (for "prompt" workflow type)
  crawlDepth?: number | "all" // How many pages to crawl for design-guidelines workflow
  // PR creation params
  githubPat?: string
  repoOwner?: string
  repoName?: string
  baseBranch?: string
  // For before/after screenshots in PR
  productionUrl?: string
}) {
  "use workflow"

  const {
    projectName,
    repoUrl,
    repoBranch = "main",
    projectDir,
    vercelOidcToken,
    runId,
    userId,
    timestamp,
    workflowType,
    analysisTargetType = "vercel-project",
    publicUrl,
    startPath = "/",
    customPrompt,
    crawlDepth,
    githubPat,
    repoOwner,
    repoName,
    baseBranch = "main",
    productionUrl
  } = params
  // Use runId if provided (from start-fix route), otherwise generate one
  // The reportId is used for blob naming and tracking
  const reportId = runId || crypto.randomUUID()

  // Progress context for step updates
  const progressContext = userId && timestamp && runId ? { userId, timestamp, runId, projectName, workflowType } : null

  workflowLog("[Workflow] Starting cloud fix workflow...")
  workflowLog(`[Workflow] Project: ${projectName}, Repo: ${repoUrl || "(none)"}`)
  workflowLog(`[Workflow] Analysis target type: ${analysisTargetType}`)
  if (publicUrl) workflowLog(`[Workflow] Public URL: ${publicUrl}`)

  // Note: Progress updates are now handled by the parent route via Vercel's workflow status
  // The workflow's wrun_xxx ID is not available inside the workflow itself

  try {
    // ============================================================
    // STEP 1: Init - Create sandbox and capture before state
    // ============================================================
    workflowLog("[Workflow] Step 1: Initializing sandbox...")

    const initResult = await initSandbox(
      repoUrl || "https://github.com/vercel-labs/dev3000",
      repoBranch,
      projectDir,
      projectName,
      reportId,
      startPath,
      githubPat,
      vercelOidcToken,
      progressContext
    )

    workflowLog(`[Workflow] Sandbox: ${initResult.sandboxId}, CLS: ${initResult.beforeCls}`)

    let fixResult: FixResult | UrlAuditResult
    if (analysisTargetType === "url") {
      if (!publicUrl) {
        throw new Error("Missing publicUrl for url analysis")
      }
      workflowLog("[Workflow] Step 2: URL audit analysis...")
      fixResult = await urlAuditLoop(
        initResult.sandboxId,
        initResult.devUrl,
        publicUrl,
        workflowType,
        customPrompt,
        projectName,
        reportId,
        progressContext,
        initResult.timing,
        initResult.fromSnapshot,
        initResult.snapshotId
      )
    } else {
      // ============================================================
      // STEP 2: Agent Fix Loop - Single step with internal iteration
      // ============================================================
      workflowLog("[Workflow] Step 2: Agent fixing CLS issues...")

      fixResult = await agentFixLoop(
        initResult.sandboxId,
        initResult.devUrl,
        initResult.beforeCls,
        initResult.beforeGrade,
        initResult.beforeScreenshots,
        initResult.initD3kLogs,
        projectName,
        reportId,
        startPath,
        repoUrl || "https://github.com/vercel-labs/dev3000",
        repoBranch,
        projectDir,
        repoOwner,
        repoName,
        customPrompt,
        crawlDepth,
        progressContext,
        // Pass timing and snapshot info from init step
        initResult.timing,
        initResult.fromSnapshot,
        initResult.snapshotId
      )
    }

    workflowLog(`[Workflow] Result: ${fixResult.status}, After CLS: ${fixResult.afterCls}`)

    // ============================================================
    // STEP 2.5: Capture before/after screenshots (if changes and productionUrl)
    // ============================================================
    let prScreenshots: Array<{ route: string; beforeBlobUrl: string | null; afterBlobUrl: string | null }> = []

    if (analysisTargetType !== "url" && fixResult.gitDiff && productionUrl) {
      workflowLog("[Workflow] Step 2.5: Capturing before/after screenshots...")
      prScreenshots = await captureScreenshotsForPR(
        initResult.sandboxId,
        productionUrl,
        initResult.devUrl,
        projectName,
        progressContext
      )
      workflowLog(`[Workflow] Captured ${prScreenshots.length} route screenshot(s)`)
    } else if (!productionUrl) {
      workflowLog("[Workflow] Skipping screenshots: No production URL provided")
    }

    // ============================================================
    // STEP 3: Create PR (only if we have changes and a GitHub PAT)
    // ============================================================
    let prResult: { prUrl: string; prNumber: number; branch: string } | null = null
    let prError: string | null = null

    if (analysisTargetType !== "url" && fixResult.gitDiff && githubPat && repoOwner && repoName) {
      workflowLog("[Workflow] Step 3: Creating GitHub PR...")

      const prStepResult = await createPullRequest(
        initResult.sandboxId,
        githubPat,
        repoOwner,
        repoName,
        baseBranch,
        projectName,
        fixResult.beforeCls,
        fixResult.afterCls,
        reportId,
        progressContext,
        prScreenshots
      )

      // Check if result is an error object
      if (prStepResult && "error" in prStepResult) {
        prError = (prStepResult as { error: string }).error
        workflowLog(`[Workflow] PR creation failed: ${prError}`)
      } else if (prStepResult && "prUrl" in prStepResult) {
        prResult = prStepResult
        workflowLog(`[Workflow] PR created: ${prResult.prUrl}`)
      } else {
        prError = "Unknown PR creation failure"
        workflowLog("[Workflow] PR creation failed with unknown error")
      }
    } else {
      if (!fixResult.gitDiff) {
        workflowLog("[Workflow] Skipping PR: No changes to commit")
      } else if (!githubPat) {
        workflowLog("[Workflow] Skipping PR: No GitHub PAT provided")
      } else {
        workflowLog("[Workflow] Skipping PR: Missing repo owner/name")
      }
    }

    // Cleanup sandbox
    await cleanupSandbox(initResult.sandboxId)

    // Save final "done" status (this is crucial since API returns immediately)
    if (progressContext) {
      await saveDoneStatus(progressContext, fixResult.reportBlobUrl, prResult?.prUrl || null, prError)
      workflowLog(`[Workflow] Saved final "done" status for ${progressContext.runId}`)
    }

    return Response.json({
      blobUrl: fixResult.reportBlobUrl,
      reportId: fixResult.reportId,
      status: fixResult.status,
      beforeCls: fixResult.beforeCls,
      afterCls: fixResult.afterCls,
      pr: prResult,
      prError
    })
  } catch (error) {
    workflowLog(`[Workflow] Error: ${error instanceof Error ? error.message : String(error)}`)
    // Save failure status via step function
    if (progressContext) {
      await saveFailureStatus(progressContext, error instanceof Error ? error.message : String(error))
    }
    throw error // Re-throw so the workflow framework knows it failed
  }
}

// ============================================================
// Step wrapper functions with "use step" directive
// ============================================================

interface ProgressContext {
  userId: string
  timestamp: string
  runId: string
  projectName: string
  workflowType?: string
}

async function initSandbox(
  repoUrl: string,
  branch: string,
  projectDir: string | undefined,
  projectName: string,
  reportId: string,
  startPath: string,
  githubPat?: string,
  vercelOidcToken?: string,
  progressContext?: ProgressContext | null
): Promise<InitResult> {
  "use step"
  const { initSandboxStep } = await import("./steps")
  return initSandboxStep(
    repoUrl,
    branch,
    projectDir,
    projectName,
    reportId,
    startPath,
    githubPat,
    vercelOidcToken,
    progressContext
  )
}

async function agentFixLoop(
  sandboxId: string,
  devUrl: string,
  beforeCls: number | null,
  beforeGrade: "good" | "needs-improvement" | "poor" | null,
  beforeScreenshots: Array<{ timestamp: number; blobUrl: string; label?: string }>,
  initD3kLogs: string,
  projectName: string,
  reportId: string,
  startPath: string,
  repoUrl: string,
  repoBranch: string,
  projectDir?: string,
  repoOwner?: string,
  repoName?: string,
  customPrompt?: string,
  crawlDepth?: number | "all",
  progressContext?: ProgressContext | null,
  initTiming?: InitResult["timing"],
  fromSnapshot?: boolean,
  snapshotId?: string
): Promise<FixResult> {
  "use step"
  const { agentFixLoopStep } = await import("./steps")
  return agentFixLoopStep(
    sandboxId,
    devUrl,
    beforeCls,
    beforeGrade,
    beforeScreenshots,
    initD3kLogs,
    projectName,
    reportId,
    startPath,
    repoUrl,
    repoBranch,
    projectDir,
    repoOwner,
    repoName,
    customPrompt,
    crawlDepth,
    progressContext,
    initTiming,
    fromSnapshot,
    snapshotId
  )
}

async function urlAuditLoop(
  sandboxId: string,
  sandboxDevUrl: string,
  targetUrl: string,
  workflowType: string | undefined,
  customPrompt: string | undefined,
  projectName: string,
  reportId: string,
  progressContext?: ProgressContext | null,
  initTiming?: InitResult["timing"],
  fromSnapshot?: boolean,
  snapshotId?: string
): Promise<UrlAuditResult> {
  "use step"
  const { urlAuditStep } = await import("./steps")
  return urlAuditStep(
    sandboxId,
    sandboxDevUrl,
    targetUrl,
    workflowType,
    customPrompt,
    projectName,
    reportId,
    progressContext,
    initTiming,
    fromSnapshot,
    snapshotId
  )
}

async function cleanupSandbox(sandboxId: string): Promise<void> {
  "use step"
  const steps = await import("./steps")
  return steps.cleanupSandbox(sandboxId)
}

async function captureScreenshotsForPR(
  sandboxId: string,
  productionUrl: string,
  localhostUrl: string,
  projectName: string,
  progressContext?: ProgressContext | null
): Promise<Array<{ route: string; beforeBlobUrl: string | null; afterBlobUrl: string | null }>> {
  "use step"
  const { captureScreenshotsForPRStep } = await import("./steps")
  return captureScreenshotsForPRStep(sandboxId, productionUrl, localhostUrl, projectName, progressContext)
}

async function createPullRequest(
  sandboxId: string,
  githubPat: string,
  repoOwner: string,
  repoName: string,
  baseBranch: string,
  projectName: string,
  beforeCls: number | null,
  afterCls: number | null,
  reportId: string,
  progressContext?: ProgressContext | null,
  prScreenshots?: Array<{ route: string; beforeBlobUrl: string | null; afterBlobUrl: string | null }>
): Promise<{ prUrl: string; prNumber: number; branch: string } | { error: string } | null> {
  "use step"
  const { createPullRequestStep } = await import("./steps")
  return createPullRequestStep(
    sandboxId,
    githubPat,
    repoOwner,
    repoName,
    baseBranch,
    projectName,
    beforeCls,
    afterCls,
    reportId,
    progressContext,
    prScreenshots
  )
}

async function saveDoneStatus(
  progressContext: ProgressContext,
  reportBlobUrl: string,
  prUrl: string | null,
  prError: string | null
): Promise<void> {
  "use step"
  const { saveWorkflowRun } = await import("@/lib/workflow-storage")
  await saveWorkflowRun({
    id: progressContext.runId,
    userId: progressContext.userId,
    projectName: progressContext.projectName,
    timestamp: progressContext.timestamp,
    status: "done",
    type:
      (progressContext.workflowType as
        | "cls-fix"
        | "prompt"
        | "design-guidelines"
        | "react-performance"
        | "url-audit"
        | "turbopack-bundle-analyzer") || "cls-fix",
    completedAt: new Date().toISOString(),
    reportBlobUrl,
    prUrl: prUrl || undefined,
    prError: prError || undefined
  })
}

async function saveFailureStatus(progressContext: ProgressContext, errorMessage: string): Promise<void> {
  "use step"
  try {
    const { saveWorkflowRun } = await import("@/lib/workflow-storage")
    await saveWorkflowRun({
      id: progressContext.runId,
      userId: progressContext.userId,
      projectName: progressContext.projectName,
      timestamp: progressContext.timestamp,
      status: "failure",
      type:
        (progressContext.workflowType as
          | "cls-fix"
          | "prompt"
          | "design-guidelines"
          | "react-performance"
          | "url-audit"
          | "turbopack-bundle-analyzer") || "cls-fix",
      completedAt: new Date().toISOString(),
      error: errorMessage
    })
    console.log(`[Workflow] Saved failure status for ${progressContext.runId}`)
  } catch (saveErr) {
    console.log(`[Workflow] Failed to save failure status: ${saveErr}`)
  }
}
