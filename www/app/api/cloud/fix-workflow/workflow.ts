/**
 * Cloud Fix Workflow - Simplified "Local-style" Architecture
 *
 * Designed to match the fast, iterative local d3k experience:
 * - 2 steps instead of many
 * - Agent controls the fix loop (not workflow orchestration)
 * - Agent has `diagnose` tool for real-time CLS feedback
 * - Report generated inline at end of agent step
 *
 * Step 1 (Init): Create sandbox, start d3k, capture initial CLS
 * Step 2 (Fix):  Agent iterates with diagnose→fix→verify until done
 */

const workflowLog = console.log

interface InitResult {
  sandboxId: string
  devUrl: string
  mcpUrl: string
  reportId: string
  beforeCls: number | null
  beforeGrade: "good" | "needs-improvement" | "poor" | null
  beforeScreenshots: Array<{ timestamp: number; blobUrl: string; label?: string }>
  initD3kLogs: string
  // Timing and snapshot info
  timing: {
    totalMs: number
    sandboxCreation: {
      totalMs: number
      steps: Array<{ name: string; durationMs: number; startedAt: string }>
    }
    steps: Array<{ name: string; durationMs: number; startedAt: string }>
  }
  fromSnapshot: boolean
  snapshotId?: string
}

interface FixResult {
  reportBlobUrl: string
  reportId: string
  beforeCls: number | null
  afterCls: number | null
  status: "improved" | "unchanged" | "degraded" | "no-changes"
  agentSummary: string
  gitDiff: string | null
}

/**
 * Main workflow - simplified to 2 steps
 */
export async function cloudFixWorkflow(params: {
  repoUrl: string
  repoBranch?: string
  projectName: string
  vercelOidcToken?: string
  runId?: string // Tracking ID generated by start-fix route
  userId?: string // For progress updates
  timestamp?: string // For progress updates
  workflowType?: string // For progress updates
  startPath?: string // Page path to analyze (e.g., "/about")
  customPrompt?: string // User's custom instructions (for "prompt" workflow type)
  crawlDepth?: number | "all" // How many pages to crawl for design-guidelines workflow
  // PR creation params
  githubPat?: string
  repoOwner?: string
  repoName?: string
  baseBranch?: string
}) {
  "use workflow"

  const {
    projectName,
    repoUrl,
    repoBranch = "main",
    vercelOidcToken,
    runId,
    userId,
    timestamp,
    workflowType,
    startPath = "/",
    customPrompt,
    crawlDepth,
    githubPat,
    repoOwner,
    repoName,
    baseBranch = "main"
  } = params
  // Use runId if provided (from start-fix route), otherwise generate one
  // The reportId is used for blob naming and tracking
  const reportId = runId || crypto.randomUUID()

  // Progress context for step updates
  const progressContext = userId && timestamp && runId ? { userId, timestamp, runId, projectName, workflowType } : null

  workflowLog("[Workflow] Starting cloud fix workflow...")
  workflowLog(`[Workflow] Project: ${projectName}, Repo: ${repoUrl}`)

  // Note: Progress updates are now handled by the parent route via Vercel's workflow status
  // The workflow's wrun_xxx ID is not available inside the workflow itself

  try {
    // ============================================================
    // STEP 1: Init - Create sandbox and capture before state
    // ============================================================
    workflowLog("[Workflow] Step 1: Initializing sandbox...")

    const initResult = await initSandbox(
      repoUrl,
      repoBranch,
      projectName,
      reportId,
      startPath,
      vercelOidcToken,
      progressContext
    )

    workflowLog(`[Workflow] Sandbox: ${initResult.sandboxId}, CLS: ${initResult.beforeCls}`)

    // ============================================================
    // STEP 2: Agent Fix Loop - Single step with internal iteration
    // ============================================================
    workflowLog("[Workflow] Step 2: Agent fixing CLS issues...")

    const fixResult = await agentFixLoop(
      initResult.sandboxId,
      initResult.devUrl,
      initResult.mcpUrl,
      initResult.beforeCls,
      initResult.beforeGrade,
      initResult.beforeScreenshots,
      initResult.initD3kLogs,
      projectName,
      reportId,
      startPath,
      customPrompt,
      crawlDepth,
      progressContext,
      // Pass timing and snapshot info from init step
      initResult.timing,
      initResult.fromSnapshot,
      initResult.snapshotId
    )

    workflowLog(`[Workflow] Result: ${fixResult.status}, After CLS: ${fixResult.afterCls}`)

    // ============================================================
    // STEP 3: Create PR (only if we have changes and a GitHub PAT)
    // ============================================================
    let prResult: { prUrl: string; prNumber: number; branch: string } | null = null
    let prError: string | null = null

    if (fixResult.gitDiff && githubPat && repoOwner && repoName) {
      workflowLog("[Workflow] Step 3: Creating GitHub PR...")

      const prStepResult = await createPullRequest(
        initResult.sandboxId,
        githubPat,
        repoOwner,
        repoName,
        baseBranch,
        projectName,
        fixResult.beforeCls,
        fixResult.afterCls,
        reportId,
        progressContext
      )

      // Check if result is an error object
      if (prStepResult && "error" in prStepResult) {
        prError = (prStepResult as { error: string }).error
        workflowLog(`[Workflow] PR creation failed: ${prError}`)
      } else if (prStepResult && "prUrl" in prStepResult) {
        prResult = prStepResult
        workflowLog(`[Workflow] PR created: ${prResult.prUrl}`)
      } else {
        prError = "Unknown PR creation failure"
        workflowLog("[Workflow] PR creation failed with unknown error")
      }
    } else {
      if (!fixResult.gitDiff) {
        workflowLog("[Workflow] Skipping PR: No changes to commit")
      } else if (!githubPat) {
        workflowLog("[Workflow] Skipping PR: No GitHub PAT provided")
      } else {
        workflowLog("[Workflow] Skipping PR: Missing repo owner/name")
      }
    }

    // Cleanup sandbox
    await cleanupSandbox(initResult.sandboxId)

    // Save final "done" status (this is crucial since API returns immediately)
    if (progressContext) {
      await saveDoneStatus(progressContext, fixResult.reportBlobUrl, prResult?.prUrl || null, prError)
      workflowLog(`[Workflow] Saved final "done" status for ${progressContext.runId}`)
    }

    return Response.json({
      blobUrl: fixResult.reportBlobUrl,
      reportId: fixResult.reportId,
      status: fixResult.status,
      beforeCls: fixResult.beforeCls,
      afterCls: fixResult.afterCls,
      pr: prResult,
      prError
    })
  } catch (error) {
    workflowLog(`[Workflow] Error: ${error instanceof Error ? error.message : String(error)}`)
    // Save failure status via step function
    if (progressContext) {
      await saveFailureStatus(progressContext, error instanceof Error ? error.message : String(error))
    }
    throw error // Re-throw so the workflow framework knows it failed
  }
}

// ============================================================
// Step wrapper functions with "use step" directive
// ============================================================

interface ProgressContext {
  userId: string
  timestamp: string
  runId: string
  projectName: string
  workflowType?: string
}

async function initSandbox(
  repoUrl: string,
  branch: string,
  projectName: string,
  reportId: string,
  startPath: string,
  vercelOidcToken?: string,
  progressContext?: ProgressContext | null
): Promise<InitResult> {
  "use step"
  const { initSandboxStep } = await import("./steps")
  return initSandboxStep(repoUrl, branch, projectName, reportId, startPath, vercelOidcToken, progressContext)
}

async function agentFixLoop(
  sandboxId: string,
  devUrl: string,
  mcpUrl: string,
  beforeCls: number | null,
  beforeGrade: "good" | "needs-improvement" | "poor" | null,
  beforeScreenshots: Array<{ timestamp: number; blobUrl: string; label?: string }>,
  initD3kLogs: string,
  projectName: string,
  reportId: string,
  startPath: string,
  customPrompt?: string,
  crawlDepth?: number | "all",
  progressContext?: ProgressContext | null,
  initTiming?: InitResult["timing"],
  fromSnapshot?: boolean,
  snapshotId?: string
): Promise<FixResult> {
  "use step"
  const { agentFixLoopStep } = await import("./steps")
  return agentFixLoopStep(
    sandboxId,
    devUrl,
    mcpUrl,
    beforeCls,
    beforeGrade,
    beforeScreenshots,
    initD3kLogs,
    projectName,
    reportId,
    startPath,
    customPrompt,
    crawlDepth,
    progressContext,
    initTiming,
    fromSnapshot,
    snapshotId
  )
}

async function cleanupSandbox(sandboxId: string): Promise<void> {
  "use step"
  const steps = await import("./steps")
  return steps.cleanupSandbox(sandboxId)
}

async function createPullRequest(
  sandboxId: string,
  githubPat: string,
  repoOwner: string,
  repoName: string,
  baseBranch: string,
  projectName: string,
  beforeCls: number | null,
  afterCls: number | null,
  reportId: string,
  progressContext?: ProgressContext | null
): Promise<{ prUrl: string; prNumber: number; branch: string } | { error: string } | null> {
  "use step"
  const { createPullRequestStep } = await import("./steps")
  return createPullRequestStep(
    sandboxId,
    githubPat,
    repoOwner,
    repoName,
    baseBranch,
    projectName,
    beforeCls,
    afterCls,
    reportId,
    progressContext
  )
}

async function saveDoneStatus(
  progressContext: ProgressContext,
  reportBlobUrl: string,
  prUrl: string | null,
  prError: string | null
): Promise<void> {
  "use step"
  const { saveWorkflowRun } = await import("@/lib/workflow-storage")
  await saveWorkflowRun({
    id: progressContext.runId,
    userId: progressContext.userId,
    projectName: progressContext.projectName,
    timestamp: progressContext.timestamp,
    status: "done",
    type: (progressContext.workflowType as "cls-fix" | "prompt" | "design-guidelines") || "cls-fix",
    completedAt: new Date().toISOString(),
    reportBlobUrl,
    prUrl: prUrl || undefined,
    prError: prError || undefined
  })
}

async function saveFailureStatus(progressContext: ProgressContext, errorMessage: string): Promise<void> {
  "use step"
  try {
    const { saveWorkflowRun } = await import("@/lib/workflow-storage")
    await saveWorkflowRun({
      id: progressContext.runId,
      userId: progressContext.userId,
      projectName: progressContext.projectName,
      timestamp: progressContext.timestamp,
      status: "failure",
      type: (progressContext.workflowType as "cls-fix" | "prompt" | "design-guidelines") || "cls-fix",
      completedAt: new Date().toISOString(),
      error: errorMessage
    })
    console.log(`[Workflow] Saved failure status for ${progressContext.runId}`)
  } catch (saveErr) {
    console.log(`[Workflow] Failed to save failure status: ${saveErr}`)
  }
}
