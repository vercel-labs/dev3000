/**
 * Cloud Fix Workflow - Simplified "Local-style" Architecture
 *
 * Designed to match the fast, iterative local d3k experience:
 * - 2 steps instead of many
 * - Agent controls the fix loop (not workflow orchestration)
 * - Agent has `diagnose` tool for real-time CLS feedback
 * - Report generated inline at end of agent step
 *
 * Step 1 (Init): Create sandbox, start d3k, capture initial CLS
 * Step 2 (Fix):  Agent iterates with diagnose→fix→verify until done
 */

const workflowLog = console.log

interface InitResult {
  sandboxId: string
  devUrl: string
  mcpUrl: string
  reportId: string
  beforeCls: number | null
  beforeGrade: "good" | "needs-improvement" | "poor" | null
  beforeScreenshots: Array<{ timestamp: number; blobUrl: string; label?: string }>
  initD3kLogs: string
}

interface FixResult {
  reportBlobUrl: string
  reportId: string
  beforeCls: number | null
  afterCls: number | null
  status: "improved" | "unchanged" | "degraded" | "no-changes"
  agentSummary: string
  gitDiff: string | null
}

/**
 * Main workflow - simplified to 2 steps
 */
export async function cloudFixWorkflow(params: {
  repoUrl: string
  repoBranch?: string
  projectName: string
  vercelOidcToken?: string
  runId?: string // Tracking ID generated by start-fix route
  userId?: string // For progress updates
  timestamp?: string // For progress updates
  workflowType?: string // For progress updates
}) {
  "use workflow"

  const { projectName, repoUrl, repoBranch = "main", vercelOidcToken, runId, userId, timestamp, workflowType } = params
  // Use runId if provided (from start-fix route), otherwise generate one
  // The reportId is used for blob naming and tracking
  const reportId = runId || crypto.randomUUID()

  // Progress context for step updates
  const progressContext = userId && timestamp && runId ? { userId, timestamp, runId, projectName, workflowType } : null

  workflowLog("[Workflow] Starting cloud fix workflow...")
  workflowLog(`[Workflow] Project: ${projectName}, Repo: ${repoUrl}`)

  // Note: Progress updates are now handled by the parent route via Vercel's workflow status
  // The workflow's wrun_xxx ID is not available inside the workflow itself

  // ============================================================
  // STEP 1: Init - Create sandbox and capture before state
  // ============================================================
  workflowLog("[Workflow] Step 1: Initializing sandbox...")

  const initResult = await initSandbox(repoUrl, repoBranch, projectName, reportId, vercelOidcToken, progressContext)

  workflowLog(`[Workflow] Sandbox: ${initResult.sandboxId}, CLS: ${initResult.beforeCls}`)

  // ============================================================
  // STEP 2: Agent Fix Loop - Single step with internal iteration
  // ============================================================
  workflowLog("[Workflow] Step 2: Agent fixing CLS issues...")

  const fixResult = await agentFixLoop(
    initResult.sandboxId,
    initResult.devUrl,
    initResult.mcpUrl,
    initResult.beforeCls,
    initResult.beforeGrade,
    initResult.beforeScreenshots,
    initResult.initD3kLogs,
    projectName,
    reportId,
    progressContext
  )

  workflowLog(`[Workflow] Result: ${fixResult.status}, After CLS: ${fixResult.afterCls}`)

  // Cleanup sandbox
  await cleanupSandbox(initResult.sandboxId)

  return Response.json({
    blobUrl: fixResult.reportBlobUrl,
    reportId: fixResult.reportId,
    status: fixResult.status,
    beforeCls: fixResult.beforeCls,
    afterCls: fixResult.afterCls
  })
}

// ============================================================
// Step wrapper functions with "use step" directive
// ============================================================

interface ProgressContext {
  userId: string
  timestamp: string
  runId: string
  projectName: string
  workflowType?: string
}

async function initSandbox(
  repoUrl: string,
  branch: string,
  projectName: string,
  reportId: string,
  vercelOidcToken?: string,
  progressContext?: ProgressContext | null
): Promise<InitResult> {
  "use step"
  const { initSandboxStep } = await import("./steps")
  return initSandboxStep(repoUrl, branch, projectName, reportId, vercelOidcToken, progressContext)
}

async function agentFixLoop(
  sandboxId: string,
  devUrl: string,
  mcpUrl: string,
  beforeCls: number | null,
  beforeGrade: "good" | "needs-improvement" | "poor" | null,
  beforeScreenshots: Array<{ timestamp: number; blobUrl: string; label?: string }>,
  initD3kLogs: string,
  projectName: string,
  reportId: string,
  progressContext?: ProgressContext | null
): Promise<FixResult> {
  "use step"
  const { agentFixLoopStep } = await import("./steps")
  return agentFixLoopStep(
    sandboxId,
    devUrl,
    mcpUrl,
    beforeCls,
    beforeGrade,
    beforeScreenshots,
    initD3kLogs,
    projectName,
    reportId,
    progressContext
  )
}

async function cleanupSandbox(sandboxId: string): Promise<void> {
  "use step"
  const steps = await import("./steps")
  return steps.cleanupSandbox(sandboxId)
}
