/**
 * Cloud Fix Workflow - Simplified "Local-style" Architecture
 *
 * Designed to match the fast, iterative local d3k experience:
 * - 2 steps instead of many
 * - Agent controls the fix loop (not workflow orchestration)
 * - Agent has `diagnose` tool for real-time CLS feedback
 * - Report generated inline at end of agent step
 *
 * Step 1 (Init): Create sandbox, start d3k, capture initial CLS
 * Step 2 (Fix):  Agent iterates with diagnose→fix→verify until done
 */

const workflowLog = console.log

interface InitResult {
  sandboxId: string
  devUrl: string
  mcpUrl: string
  reportId: string
  beforeCls: number | null
  beforeGrade: "good" | "needs-improvement" | "poor" | null
  beforeScreenshots: Array<{ timestamp: number; blobUrl: string; label?: string }>
  initD3kLogs: string
}

interface FixResult {
  reportBlobUrl: string
  reportId: string
  beforeCls: number | null
  afterCls: number | null
  status: "improved" | "unchanged" | "degraded" | "no-changes"
  agentSummary: string
  gitDiff: string | null
}

/**
 * Main workflow - simplified to 2 steps
 */
export async function cloudFixWorkflow(params: {
  repoUrl: string
  repoBranch?: string
  projectName: string
  vercelOidcToken?: string
  runId?: string // Tracking ID generated by start-fix route
  userId?: string // For progress updates
  timestamp?: string // For progress updates
  workflowType?: string // For progress updates
  startPath?: string // Page path to analyze (e.g., "/about")
  // PR creation params
  githubPat?: string
  repoOwner?: string
  repoName?: string
  baseBranch?: string
}) {
  "use workflow"

  const {
    projectName,
    repoUrl,
    repoBranch = "main",
    vercelOidcToken,
    runId,
    userId,
    timestamp,
    workflowType,
    startPath = "/",
    githubPat,
    repoOwner,
    repoName,
    baseBranch = "main"
  } = params
  // Use runId if provided (from start-fix route), otherwise generate one
  // The reportId is used for blob naming and tracking
  const reportId = runId || crypto.randomUUID()

  // Progress context for step updates
  const progressContext = userId && timestamp && runId ? { userId, timestamp, runId, projectName, workflowType } : null

  workflowLog("[Workflow] Starting cloud fix workflow...")
  workflowLog(`[Workflow] Project: ${projectName}, Repo: ${repoUrl}`)

  // Note: Progress updates are now handled by the parent route via Vercel's workflow status
  // The workflow's wrun_xxx ID is not available inside the workflow itself

  // ============================================================
  // STEP 1: Init - Create sandbox and capture before state
  // ============================================================
  workflowLog("[Workflow] Step 1: Initializing sandbox...")

  const initResult = await initSandbox(repoUrl, repoBranch, projectName, reportId, startPath, vercelOidcToken, progressContext)

  workflowLog(`[Workflow] Sandbox: ${initResult.sandboxId}, CLS: ${initResult.beforeCls}`)

  // ============================================================
  // STEP 2: Agent Fix Loop - Single step with internal iteration
  // ============================================================
  workflowLog("[Workflow] Step 2: Agent fixing CLS issues...")

  const fixResult = await agentFixLoop(
    initResult.sandboxId,
    initResult.devUrl,
    initResult.mcpUrl,
    initResult.beforeCls,
    initResult.beforeGrade,
    initResult.beforeScreenshots,
    initResult.initD3kLogs,
    projectName,
    reportId,
    startPath,
    progressContext
  )

  workflowLog(`[Workflow] Result: ${fixResult.status}, After CLS: ${fixResult.afterCls}`)

  // ============================================================
  // STEP 3: Create PR (only if we have changes and a GitHub PAT)
  // ============================================================
  let prResult: { prUrl: string; prNumber: number; branch: string } | null = null
  let prError: string | null = null

  if (fixResult.gitDiff && githubPat && repoOwner && repoName) {
    workflowLog("[Workflow] Step 3: Creating GitHub PR...")

    const prStepResult = await createPullRequest(
      initResult.sandboxId,
      githubPat,
      repoOwner,
      repoName,
      baseBranch,
      projectName,
      fixResult.beforeCls,
      fixResult.afterCls,
      reportId,
      progressContext
    )

    // Check if result is an error object
    if (prStepResult && "error" in prStepResult) {
      prError = (prStepResult as { error: string }).error
      workflowLog(`[Workflow] PR creation failed: ${prError}`)
    } else if (prStepResult && "prUrl" in prStepResult) {
      prResult = prStepResult
      workflowLog(`[Workflow] PR created: ${prResult.prUrl}`)
    } else {
      prError = "Unknown PR creation failure"
      workflowLog("[Workflow] PR creation failed with unknown error")
    }
  } else {
    if (!fixResult.gitDiff) {
      workflowLog("[Workflow] Skipping PR: No changes to commit")
    } else if (!githubPat) {
      workflowLog("[Workflow] Skipping PR: No GitHub PAT provided")
    } else {
      workflowLog("[Workflow] Skipping PR: Missing repo owner/name")
    }
  }

  // Cleanup sandbox
  await cleanupSandbox(initResult.sandboxId)

  return Response.json({
    blobUrl: fixResult.reportBlobUrl,
    reportId: fixResult.reportId,
    status: fixResult.status,
    beforeCls: fixResult.beforeCls,
    afterCls: fixResult.afterCls,
    pr: prResult,
    prError
  })
}

// ============================================================
// Step wrapper functions with "use step" directive
// ============================================================

interface ProgressContext {
  userId: string
  timestamp: string
  runId: string
  projectName: string
  workflowType?: string
}

async function initSandbox(
  repoUrl: string,
  branch: string,
  projectName: string,
  reportId: string,
  startPath: string,
  vercelOidcToken?: string,
  progressContext?: ProgressContext | null
): Promise<InitResult> {
  "use step"
  const { initSandboxStep } = await import("./steps")
  return initSandboxStep(repoUrl, branch, projectName, reportId, startPath, vercelOidcToken, progressContext)
}

async function agentFixLoop(
  sandboxId: string,
  devUrl: string,
  mcpUrl: string,
  beforeCls: number | null,
  beforeGrade: "good" | "needs-improvement" | "poor" | null,
  beforeScreenshots: Array<{ timestamp: number; blobUrl: string; label?: string }>,
  initD3kLogs: string,
  projectName: string,
  reportId: string,
  startPath: string,
  progressContext?: ProgressContext | null
): Promise<FixResult> {
  "use step"
  const { agentFixLoopStep } = await import("./steps")
  return agentFixLoopStep(
    sandboxId,
    devUrl,
    mcpUrl,
    beforeCls,
    beforeGrade,
    beforeScreenshots,
    initD3kLogs,
    projectName,
    reportId,
    startPath,
    progressContext
  )
}

async function cleanupSandbox(sandboxId: string): Promise<void> {
  "use step"
  const steps = await import("./steps")
  return steps.cleanupSandbox(sandboxId)
}

async function createPullRequest(
  sandboxId: string,
  githubPat: string,
  repoOwner: string,
  repoName: string,
  baseBranch: string,
  projectName: string,
  beforeCls: number | null,
  afterCls: number | null,
  reportId: string,
  progressContext?: ProgressContext | null
): Promise<{ prUrl: string; prNumber: number; branch: string } | { error: string } | null> {
  "use step"
  const { createPullRequestStep } = await import("./steps")
  return createPullRequestStep(
    sandboxId,
    githubPat,
    repoOwner,
    repoName,
    baseBranch,
    projectName,
    beforeCls,
    afterCls,
    reportId,
    progressContext
  )
}
